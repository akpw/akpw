---
layout: post
title: "Helping King Leonidas drive a chariot"
description: "Helping King Leonidas drive a chariot"
category: articles
tags: [Python, BFS, Time flows]
comments: true
---


My 15-years-old niece came and asked to help with her home work. "Sure, bring it on!" I said, expecting something along the lines of "one starts sooner, another goes faster". What followed surprised me, and leaded to [the gist](https://gist.github.com/akpw/9a30020008294f4a7d6229e076335d34) as well to the rest of this article to explain it.

**The home work assignment**

What I thought should be a 'sooner, faster' stuff instead turned out to be:

> King Leonidas drives its chariot on a rectangular field of size H × W (1 ≤ H, W ≤ 1000). The chariot is a special model that can only drive forward and needs some help to make a turn. The help usually comes in the form of a few strong spartan warriors who can lift the chariot and turn it to one of the 8 directions (vertical, horizontal, or two diagonals). The terrain around Sparta is rocky and some of the cells are impassable. King Leonid wants to keep his warriors fresh for upcoming fight with Xerxes, and therefore needs to make least amount of turns possible.

"Hmmm... Are you sure it's _your_ home work??", I asked.

_"Yep. I already tried Dijkstra but run into some problems, can you help?"_

"Oh, time flows... What language do you need to do it with?"

_"Well, C++ would be ideal for performance._"

"How about Swift? It's kind of cool and pretty fast, you know..."

_"That new javascript-like language?"_

"Javascript-like what??"

_"OK, OK I got the coolness. But sorry, not for this one. They also accept Python though..."_

So no Swift allowed. But Python... Deal then.


**BFS to the rescue**

The task seems to be a classical shortest path problem, and since there are no notion of weights for the edges a standard BFS should do the job.

Using a plain python list to represent the queue of paths, this translates into:

#### BFS search

{% highlight python %}
class PathFinder:
    def shortest_path(self, start_point, end_point):
        # the queue of paths
        queue = []
        visited = set()
        queue.append([start_point])
        while queue:
            # the first path from the queue
            path = queue.pop(0)

            # the last point from the path
            current_point = path[-1]

            # path found?
            if current_point == end_point:
                return path

            #### adjacent points for the current point
            for adjacent_point in self._adjacent_points(current_point):
                if adjacent_point not in visited:
                    visited.add(adjacent_point)
                    # construct a new path and add it to the queue
                    new_path = list(path)
                    new_path.append(adjacent_point)
                    queue.append(new_path)
        # no path found
        return []
{% endhighlight %}


**The field and the points**

Now that the core algorithmic part is done, lets' add some meat to specific terms of the task.
The `Point` class represents a point in the field's coordinate system.

{% highlight python %}
class Point:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y
{% endhighlight %}

The field itself can be represented as a matrix, where obstacles can be visualized as `'x'` while usable cells will be displayed as `' ' `:
{% highlight python %}
[' ', ' ', 'x', ' ', ' ']
['x', ' ', 'x', ' ', 'x']
['x', 'x', ' ', ' ', 'x']
['x', 'x', 'x', ' ', 'x']
[' ', 'x', ' ', 'x', ' ']
['x', ' ', 'x', ' ', 'x']
['x', 'x', 'x', ' ', ' ']
{% endhighlight %}

For internal purposes, let's use more standard `0` for representation of an obstacle and `1` to indicate a free space.

We will obviously need to generate a field of any reasonable size, which can be done with the following comprehension:
{% highlight python %}
import random
range_X, range_Y = 5, 7  # change these as needed for the test
test_field = [[random.randrange(2) for _ in range(range_X)] for _ in range(range_Y)]
{% endhighlight %}

To enable comparison between points as well as putting points to the `set` of visited nodes, let's beef up our `Point` class some more:

{% highlight python %}
class Point:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
    def __hash__(self):
        return hash((self.x, self.y))
    def __str__(self):
        return '({0}, {1})'.format(self.x, self.y)
{% endhighlight %}

**Making the chariot wheels turn**

To make our chariot move in the field, now we need to define some appropriate rules while at the same time giving our [BFS search code](#bfs-search) a list of adjacent points to work with:

{% highlight python %}
    ## finds adjucent points
    def _adjacent_points(self, point):
        # can take a step into either directions
        # x-1 | x+1 | y-1 | y+1
        adjacent_points = []
        for x in range(-1,2):       # -1 <- x -> +1
            adj_x = point.x + x
            if adj_x < 0:
                adj_x = 0
            if adj_x >= self.max_x:
                adj_x = self.max_x - 1

            for y in range (-1,2):    # -1 <- y -> +1
                adj_y = point.y + y
                if adj_y < 0:
                    adj_y = 0
                if adj_y >= self.max_y:
                    adj_y = self.max_y - 1

                if adj_x == point.x and adj_y == point.y:
                    continue
                adjacent_point = Point(adj_x, adj_y)
                if self._is_obstacle(adjacent_point):
                    continue

                adjacent_points.append(adjacent_point)

        return adjacent_points

    @property
    def max_y(self):
        return len(self._field)
    @property
    def max_x(self):
        return len(self._field[0])

    def _is_obstacle(self, point):
        return self._field[point.y][point.x] == 0
{% endhighlight %}

That would allow required movement into either of 8 possible directions, while checking on  various constraints of the given field.

With that, most of the task code should be written and the only thing that remains is to see whether it actually do something useful.


**Visualizing success**

As it goes in real life, doing the job is goes only half the way without actually proving it. The [full gist code](https://gist.github.com/akpw/9a30020008294f4a7d6229e076335d34) goes all the way to allow defining the field size and then randomly generates that field with obstacles, as well as choosing the random start and end points.

The results for existing shortest paths are visualized as:
{% highlight python %}
['x', ' ', ' ', 'x', ' ', 'x', 'x', 'x', 'x', 'x']
['x', ' ', 'x', ' ', ' ', 'x', 'x', ' ', ' ', 'x']
[' ', 'x', 'x', ' ', 'x', 'x', ' ', 'x', ' ', ' ']
['x', 'x', ' ', ' ', ' ', ' ', ' ', 'x', 'x', ' ']
['S', 'x', ' ', 'x', ' ', 'E', ' ', ' ', 'x', 'x']
['x', '*', ' ', 'x', '*', 'x', 'x', 'x', 'x', 'x']
['x', ' ', '*', '*', 'x', 'x', ' ', 'x', 'x', 'x']
['x', 'x', ' ', 'x', 'x', 'x', ' ', ' ', ' ', ' ']
['x', ' ', 'x', 'x', 'x', ' ', 'x', 'x', ' ', ' ']
['x', ' ', 'x', 'x', ' ', ' ', ' ', ' ', ' ', 'x']
['x', 'x', 'x', ' ', 'x', 'x', ' ', 'x', 'x', 'x']
[' ', 'x', 'x', 'x', ' ', ' ', 'x', 'x', 'x', ' ']
Shortest path:  (0, 7)->(1, 6)->(2, 5)->(3, 5)->(4, 6)->(5, 7)
Found path with distance 5 in: 0.634sec
{% endhighlight %}

Where 'x' represents an obstacle, `S` is the start point, `E` is the end point and '*'s show the actual shortest path.

The results for non-existent paths are visualized as:
{% highlight python %}
['x', ' ', ' ', 'x', ' ', 'x', 'x', 'x', 'x', 'x']
['x', ' ', 'x', ' ', ' ', 'x', 'x', ' ', ' ', 'x']
[' ', 'x', 'x', ' ', 'x', 'x', ' ', 'x', ' ', ' ']
['x', 'x', ' ', ' ', ' ', ' ', ' ', 'x', 'x', ' ']
[' ', 'x', ' ', 'x', ' ', ' ', ' ', ' ', 'x', 'x']
['x', ' ', ' ', 'x', ' ', 'x', 'x', 'x', 'x', 'x']
['x', ' ', ' ', ' ', 'x', 'x', ' ', 'x', 'x', 'x']
['x', 'x', ' ', 'x', 'x', 'x', ' ', ' ', ' ', ' ']
['x', ' ', 'x', 'x', 'x', ' ', 'x', 'x', ' ', ' ']
['x', ' ', 'x', 'x', ' ', ' ', ' ', ' ', ' ', 'x']
['x', 'x', 'x', ' ', 'x', 'x', ' ', 'x', 'x', 'x']
[' ', 'x', 'x', 'x', ' ', ' ', 'x', 'x', 'x', ' ']
No path from (4, 9) to (7, 10) (distance: -1)
No path from (9, 1) to (2, 3) (distance: -1)
No path from (8, 6) to (0, 0) (distance: -1)
{% endhighlight %}

***Conclusion***

_"[The gist](https://gist.github.com/akpw/9a30020008294f4a7d6229e076335d34) look good"_, she said. _"Performance for a field of 1000x1000" can be a bit better, but what can you aspect from people not actively writing in C++..._

Time to go back to Swift, anyway...
