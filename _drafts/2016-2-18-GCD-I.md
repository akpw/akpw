---
layout: post
title: "Swift concurrency: Practical GCD, Part I (Intro)"
description: "Swift concurrency series"
category: articles
tags: [iOS, OSX, Apple Swift, Grand Central Dispatch, Concurrency, Mobile Development]
comments: true
---

As mentioned in the previous part of the series, libdispatch aka the Grand Central Dispatch is at the core of concurrency operations for all Darwin platform. libdispatch is a low level C library that enables concurrent execution on multi-processor hardware and provides abstractions for writing concurrent code based on tasks and queues.

Despite being low level, GCD is surprisingly easy to use and is ubiquitous in all kinds of iOS / OSX applications. It makes it trivial to do things like spinning of a task on background thread and then calling back to the main UI thread with the results, while automatically taking care of the underlying complexities such as scheduling and priorities, CPU throughput, concurrency vs parallelism, etc. with appropriate values for individual platforms.

**The Basics**

In a nutshell, GCD introduces the concepts of thread-safe FIFO queues and enables submitting tasks. The queues could be either serial or concurrent, where serial queues are guaranteed to executed one task at a time in the order of the tasks' submission. Concurrent queues can execute multiple tasks at the same time, and while GCD grantees start order of the submitted task their rest of the execution details such as number of concurrently running tasks and their priorities are automatically decided by the system.

In Swift terms, a task is typically a closure and it can also be submitted to a GCD queue either synchronously or asynchronously.

With that knowledge, let's do already something:

{% highlight swift %}
let q = dispatch_get_global_queue(0,0)
dispatch_async(q) {
    print("hi from a separate thread")

    dispatch_async(dispatch_get_main_queue()) {
        print("all done, and now back to the main thread")
    }
}
{% endhighlight %}

The code above concurrently prints a message and then gets back to synchronously reports results on the main application thread.

Despite simplicity of the example, a number of things happen under the hood. After the code is submitted to one of the global concurrent queues, GCD takes care of prioritizing and scheduling its execution on one of the available CPUs, eventually spinning of a new thread or taking one from its thread pool and actually running the code.

**Let's get some more control**

With GCD taking care of all numerous platform-dependent settings around tasks scheduling & priorities, it also provides a clear and concise way for developers to express their intents.

Since iOS8, _Quality of Service_ gives developers several predefined priory levels that can be  assigned to various units of works. The priority levels can be used for queues, threads and tasks alike.

QOS breaks out things into four distinct categories:

 * _User Interactive_: work is done synchronously on the main thread, such as updating the UI

 * _User Initiated_: something that the user started, with expectation of prompt results, e.g. opening a document

 * _Utility_: work that may take a while and is not expected to be finished right away, such as uploading images while showing overall progress

 * _Background_: Not related to current activities, such as maintenance, indexing, backup, etc.

The QOS API is pretty neat, e.g. for our example basically all it takes is simply selecting the required QOS level that will then determine the appropriate system queue:

![queues]({% if site.baseurl %}{{ site.baseurl }}{% endif %}/images/QOS.png)

Code completion suggestions directly map to the to the four main QOS categories, with some additional values of _QOS_CLASS_DEFAULT_[^1], _QOS_CLASS_UNSPECIFIED_[^2], and _QOS_MIN_RELATIVE_PRIORITY_[^3].

Having mastered the QOS basics, lets evolve our code sample and run it via a playground:

{% highlight swift %}
import Foundation
import XCPlayground

XCPlaygroundPage.currentPage.needsIndefiniteExecution = true

let currentQueueLabel = {() -> String? in
    let queue_Label = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)
    return String(CString: queue_Label, encoding: NSUTF8StringEncoding)
}

let q = dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
dispatch_async(q) {
    if let label_name = currentQueueLabel() {
        print("Now on a GCD thread with QOS class: \(label_name)")
    }

    dispatch_async(dispatch_get_main_queue()) {
        if let label_name = currentQueueLabel() {
            print("And now back to: \(label_name)")
        }
        XCPlaygroundPage.currentPage.finishExecution()
    }
}
{% endhighlight %}
{% highlight bash %}
Now on a GCD thread with QOS class: com.apple.root.utility-qos
And now back to: com.apple.main-thread
{% endhighlight %}

Now this explicitly tells GCD to run submitted task on the Utility queue, a global concurrent queue for energy-efficient execution. There are three more concurrent system queues each associated with its respective QOS level, as well as the serial main queue.

While the global queues are useful and readily available, it is important to realize that they are also used by the system itself and therefore can not always be appropriate for a dedicated kind of work. For this purpose, GCD provides custom queues that can be both either serial or concurrent:

{% highlight swift %}
let queue_attributes = dispatch_queue_attr_make_with_qos_class(
                                    DISPATCH_QUEUE_SERIAL, QOS_CLASS_BACKGROUND, 0)
let custom_queue = dispatch_queue_create("com.akpw.bckg.worker", queue_attributes)
{% endhighlight %}

This creates a concurrent background custom queue that can be used for dedicated work.

***Choosing Queue type***

Five system queues along with ability to create your own custom queues provide plenty of options to choose from. So how can we choose the most appropriate for various concurrency scenarios?

The answer to this obviously depends on specific use-cases, and goes along with how we plan to submit work to the queues.

There are several way to submit tasks to queues. Most common are _dispatch_sync_, _dispatch_async_ and _dispatch_after_. Let's quickly go over each one using our custom queue:

{% highlight swift %}
import Foundation
import XCPlayground

XCPlaygroundPage.currentPage.needsIndefiniteExecution = true

let queue_attributes = dispatch_queue_attr_make_with_qos_class(
                                DISPATCH_QUEUE_SERIAL, QOS_CLASS_BACKGROUND, 0)
let custom_queue = dispatch_queue_create("com.akpw.bckg.worker", queue_attributes)

guard let mainQueueLabel = currentQueueLabel() else {XCPlaygroundPage.currentPage.finishExecution()}

print("1. submitting async from \(mainQueueLabel)")
dispatch_async(custom_queue) {
    if let queueLabel = currentQueueLabel() {
        print("2. running async on the \(queueLabel)")
    }
}
print("3. now doing something on \(mainQueueLabel)")

print("4. submitting synchronously from \(mainQueueLabel)")
dispatch_sync(custom_queue) {
    if let queueLabel = currentQueueLabel() {
        print("5. running sync on the \(queueLabel)")
    }
}
print("6. now doing something on \(mainQueueLabel)")


let delay = dispatch_time(DISPATCH_TIME_NOW,
                                Int64(NSTimeInterval(NSEC_PER_SEC) * 1))
print("7. submitting with delay from \(mainQueueLabel)")
dispatch_after(delay, custom_queue) {
    if let queueLabel = currentQueueLabel() {
        print("8. running after delay on the \(queueLabel)")
    }
    XCPlaygroundPage.currentPage.finishExecution()
}
{% endhighlight %}


{% highlight bash %}
1. submitting async from com.apple.main-thread
3. now doing something on com.apple.main-thread
4. submitting synchronously from com.apple.main-thread
2. running async on the com.akpw.bckg.worker
5. running sync on the com.akpw.bckg.worker
6. now doing something on com.apple.main-thread
7. submitting with delay from com.apple.main-thread
8. running after delay on the com.akpw.bckg.worker
{% endhighlight %}


While _dispatch_async_ just submits work to a queue and does not wait on results, dispatch_sync pauses execution of the submitting thread till the the work on the target queue is completed. _dispatch_after_ schedules execution of a task on the target queue after specified amount of delay.

With the info so far, it is easy to come up with the first rules of choosing appropriate queues.

***Main Queue***

Starting with a citation from the [Concurrency Programming Guide](https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html):

> The main dispatch queue is a globally available serial queue that executes tasks on the application’s main thread. This queue works with the application’s run loop (if one is present) to interleave the execution of queued tasks with the execution of other event sources attached to the run loop. Because it runs on your application’s main thread, the main queue is often used as a key synchronization point for an application.

Most of that does not require further explanation, and using main queue is typically a no-brainer: basically, it should only  be used for updating the UI and firing work to various worker queues.

This is also a good candidate for _dispatch_after_, where it can be used e.g. as a replacement for NSTimer-based scheduling.

An extra word of caution for using _dispatch_sync_ there, as e.g. this is guaranteed to deadlock:
{% highlight swift %}
dispatch_sync(custom_queue) {
    dispatch_sync(dispatch_get_main_queue()) {
        print("deadlocked!!!")
    }
}
{% endhighlight %}
While mistakes like that are easy to spot, variations along the same lines could be even more dangerous:
{% highlight swift %}
import Foundation
import XCPlayground

XCPlaygroundPage.currentPage.needsIndefiniteExecution = true
let custom_queue = dispatch_queue_create("com.akpw.bckg.worker", DISPATCH_QUEUE_SERIAL)

dispatch_async(custom_queue) {
    dispatch_sync(dispatch_get_main_queue()) {
        print("deadlocked!!! 👻")
    }
}

// continue doing something
// ...

dispatch_sync(custom_queue) {
    if let queueLabel = currentQueueLabel(){
        print(String(format:
            "supposly running sync on the \(queueLabel)",
            "...or perhaps not???"))
    }
}
{% endhighlight %}

A rule of thumb is to avoid using _dispatch_sync_ with serial queues unless absolutely needed, and always prefer _dispatch_async_ instead.


***Global queues***

The four concurrent queues are readily available for various concurrent tasks and typically used frequently. One thing to remember though is that they are also used by the system and therefore might not be always suitable for dedicated kind of work.

***Custom Queues***

 * Custom Serial Queue: A good choice when you want to perform background work serially and track it. This eliminates resource contention since you know only one task at a time is executing. Note that if you need the data from a method, you must inline another closure to retrieve it or
 consider using dispatch_sync.

 * Concurrent Queue: This is a common choice to perform non-UI work in the background.

* * *

[^1]: _QOS_CLASS_DEFAULT_ is simply a value used when no specific QOS info was provided, and is the default value for both queues and threads. Priority-wise, it sits between _User Interactive_ and _User Initiated_.

[^2]:_QOS_CLASS_UNSPECIFIED_ is tied to the concept of QOS propagation, where QoS is inferred  from the caller's QOS level. Such propagation simply transfers the QOS level, except for _User Interactive_ that is automatically translated to _User Initiated_.

[^3]:_QOS_MIN_RELATIVE_PRIORITY_ supports relative position within a QoS Class band. It is only within a given QOS class and intended for unusual situations such as e.g. interdependent work within same QOS class.

[^5]: A dispatch group is a way to monitor a set of block objects for completion. (You can monitor the blocks synchronously or asynchronously depending on your needs.)
Optimizing further with GCD’s API is where things really get fun. If one is creating some work that has nothing to do with the flow of execution, for instance, the DISPATCH_BLOCK_DETACHED flag can be called to action:
dispatch_block_create(DISPATCH_BLOCK_DETACHED, {
    //Work
})
The benefit here is that GCD knows the work being done inside the block has nothing to do with the flow of execution. This cuts out some of the fluff, like assigning an activity ID, QoS propagation, and other properties of the execution context


