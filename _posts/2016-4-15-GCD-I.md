---
layout: post
title: "Swift concurrency: Practical GCD, Part I Introduction to GCD queues"
description: "Swift concurrency series"
category: articles
tags: [iOS, OSX, Apple Swift, Grand Central Dispatch, Concurrency, Mobile Development]
comments: true
---

As mentioned in the previous part of the series, libdispatch aka the Grand Central Dispatch is at the core of concurrency operations for all Darwin platform. libdispatch is a low level C library that enables concurrent execution on multi-processor hardware and provides abstractions for writing concurrent code based on tasks and queues.

Despite being low level, GCD is surprisingly easy to use and is ubiquitous in all kinds of iOS / OSX applications. It makes it trivial to do things like spinning of a task on background thread and then calling back to the main UI thread with the results, while automatically taking care of the underlying complexities such as scheduling and priorities, CPU throughput, concurrency vs parallelism, etc. with appropriate values for individual platforms.

**The Basics**

In a nutshell, GCD introduces the concepts of thread-safe FIFO queues and enables submitting tasks.

GCD queues could be either serial or concurrent, where serial queues are guaranteed to executed one task at a time in the order of the tasks' submission.

Concurrent queues can execute multiple tasks at the same time. While GCD guarantees start order of the submitted task, the rest of the execution details such as number of concurrently running tasks and their priorities are automatically decided by the system.

In Swift terms, a task is typically a closure and it can be submitted to a GCD queue either synchronously or asynchronously.

With that knowledge, let's do already something:

{% highlight swift %}
let q = dispatch_get_global_queue(0, 0)
dispatch_async(q) {
    print("hi from a separate thread")

    dispatch_async(dispatch_get_main_queue()) {
        print("all done, and now back to the main thread")
    }
}
{% endhighlight %}

The code above concurrently prints a message and then gets back to synchronously reports results on the main application thread.

Despite simplicity of the example, a number of things happens under the hood. After the code is submitted to one of the global concurrent queues, GCD takes care of prioritizing and scheduling its execution on one of the available CPUs, eventually spinning of a new thread or taking one from its thread pool and actually running the code.

**Let's get some more control**

With GCD taking care of all numerous platform-dependent settings around tasks scheduling & priorities, it also provides a clear and concise way for developers to express their intents.

Since iOS8, _Quality of Service_ gives developers several predefined priory levels that can be  assigned to various units of works. The priority levels can be used for queues, threads and tasks alike.

QOS breaks out things into four distinct categories:

 * _User Interactive_: work is done synchronously on the main thread, such as updating the UI

 * _User Initiated_: something that the user started with expectation of prompt results, for example opening a document

 * _Utility_: work that may take a while and is not expected to be finished right away, such as uploading images while showing overall progress

 * _Background_: Not related to current activities, typically maintenance, indexing, backup, etc.

The QOS API is quite neat and pretty much all it takes is selecting the required QOS level that will then determine the appropriate system queue:

![queues]({% if site.baseurl %}{{ site.baseurl }}{% endif %}/images/QOS.png)

The XCode code completion suggestions directly map to the to the four main QOS categories, with some additional values of _QOS_CLASS_DEFAULT_[^1], _QOS_CLASS_UNSPECIFIED_[^2], and _QOS_MIN_RELATIVE_PRIORITY_[^3].

Having mastered the QOS basics, lets evolve our code sample and run it via a playground:

{% highlight swift %}
import Foundation
import XCPlayground

XCPlaygroundPage.currentPage.needsIndefiniteExecution = true

let currentQueueLabel = {() -> String? in
    let queue_Label = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)
    return String(CString: queue_Label, encoding: NSUTF8StringEncoding)
}

let q = dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
dispatch_async(q) {
    if let label_name = currentQueueLabel() {
        print("Now on a GCD thread with QOS class: \(label_name)")
    }

    dispatch_async(dispatch_get_main_queue()) {
        if let label_name = currentQueueLabel() {
            print("And now back to: \(label_name)")
        }
        XCPlaygroundPage.currentPage.finishExecution()
    }
}
{% endhighlight %}
{% highlight bash %}
Now on a GCD thread with QOS class: com.apple.root.utility-qos
And now back to: com.apple.main-thread
{% endhighlight %}

This explicitly tells GCD to run submitted task on the Utility queue, a global concurrent queue for energy-efficient execution. There are three more concurrent system queues each associated with its respective QOS level, as well as the serial main queue.

While the global queues are useful and readily available, it is important to realize that they are also used by the system itself and therefore can not always be appropriate for a dedicated kind of work. For this purpose, GCD provides custom queues that can be both either serial or concurrent:

{% highlight swift %}
let queue_attributes = dispatch_queue_attr_make_with_qos_class(
                                    DISPATCH_QUEUE_SERIAL, QOS_CLASS_BACKGROUND, 0)
let custom_queue = dispatch_queue_create("com.akpw.bckg.worker", queue_attributes)
{% endhighlight %}

This creates a concurrent background custom queue that can be used for dedicated work.

***Choosing Queue type***

Five system queues along with ability to create your own custom queues provide plenty of options to choose from. So how can we choose the most appropriate for various concurrency scenarios?

The answer to this obviously depends on specific use-cases, and goes along with how we plan to submit work to the queues.

There are several way to submit tasks to queues. Most common are _dispatch_sync_, _dispatch_async_ and _dispatch_after_. Let's go over each one using our custom queue:

{% highlight swift %}
import Foundation
import XCPlayground

XCPlaygroundPage.currentPage.needsIndefiniteExecution = true

let queue_attributes = dispatch_queue_attr_make_with_qos_class(
                                DISPATCH_QUEUE_SERIAL, QOS_CLASS_BACKGROUND, 0)
let custom_queue = dispatch_queue_create("com.akpw.bckg.worker", queue_attributes)

guard let mainQueueLabel = currentQueueLabel() else {XCPlaygroundPage.currentPage.finishExecution()}

print("1. submitting async from \(mainQueueLabel)")
dispatch_async(custom_queue) {
    if let queueLabel = currentQueueLabel() {
        print("2. running async on the \(queueLabel)")
    }
}
print("3. now doing something on \(mainQueueLabel)")

print("4. submitting synchronously from \(mainQueueLabel)")
dispatch_sync(custom_queue) {
    if let queueLabel = currentQueueLabel() {
        print("5. running sync on the \(queueLabel)")
    }
}
print("6. now doing something on \(mainQueueLabel)")


let delay = dispatch_time(DISPATCH_TIME_NOW,
                                Int64(NSTimeInterval(NSEC_PER_SEC) * 1))
print("7. submitting with delay from \(mainQueueLabel)")
dispatch_after(delay, custom_queue) {
    if let queueLabel = currentQueueLabel() {
        print("8. running after delay on the \(queueLabel)")
    }
    XCPlaygroundPage.currentPage.finishExecution()
}
{% endhighlight %}


{% highlight bash %}
1. submitting async from com.apple.main-thread
3. now doing something on com.apple.main-thread
4. submitting synchronously from com.apple.main-thread
2. running async on the com.akpw.bckg.worker
5. running sync on the com.akpw.bckg.worker
6. now doing something on com.apple.main-thread
7. submitting with delay from com.apple.main-thread
8. running after delay on the com.akpw.bckg.worker
{% endhighlight %}


While _dispatch_async_ just submits work to a queue and does not wait on results, dispatch_sync pauses execution of the submitting thread till the the work on the target queue is completed. _dispatch_after_ schedules execution of a task on the target queue after specified amount of delay.

Another interesting way to submit work to queues is via barrier dispatch functions, which is a good way to implement thread-safe resources and address the [readersâ€“writers](https://en.wikipedia.org/wiki/Readersâ€“writers_problem) problem. _dispach_barrier_async_ and _dispatch_barrier_sync_ work similarly to _dispatch_async_ and _dispatch_sync_, except when submitted to a concurrent queue they will actually run their tasks serially. This is best shown by example, e.g. here comes a quick implementation of a thread-safe shape-shifting creature:

{% highlight swift %}
struct ShapeShifter: CustomStringConvertible {
    var name: String
    var species: String

    private let synchronizationQueue = dispatch_queue_create(
                    "com.akpw.shapeshifter.sync_queue", DISPATCH_QUEUE_CONCURRENT)

    init(name: String, species: String) {
        self.name = name
        self.species = species
    }

    mutating func shiftShape(name: String, species: String) {
        dispatch_barrier_async(synchronizationQueue) {
            self.name = name
            self.species = species
        }
    }

    var description: String {
        var departmentDescription = ""
        dispatch_sync(synchronizationQueue) {
            departmentDescription = "\(self.name) the \(self.species)"
        }
        return departmentDescription
    }
}
{% endhighlight %}

Our shape-shifter now supports concurrent reading of its current shape, while changes of shape are serialized and synchronized between multiple threads.

With the information so far, let's now come up with the basic rules of choosing appropriate queues.

***Main Queue***

Starting with a citation from the [Concurrency Programming Guide](https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html):

> The main dispatch queue is a globally available serial queue that executes tasks on the applicationâ€™s main thread. This queue works with the applicationâ€™s run loop (if one is present) to interleave the execution of queued tasks with the execution of other event sources attached to the run loop. Because it runs on your applicationâ€™s main thread, the main queue is often used as a key synchronization point for an application.

Most of that does not require further explanation, and using main queue is typically a no-brainer: basically, it should only  be used for updating the UI and firing tasks to various worker queues.

In addition to that, main queue is also a good candidate for _dispatch_after_, where it can be used as a replacement for NSTimer-based scheduling.

An extra word of caution for using _dispatch_sync_ there, as this is guaranteed to deadlock:
{% highlight swift %}
dispatch_sync(custom_queue) {
    dispatch_sync(dispatch_get_main_queue()) {
        print("deadlocked!!!")
    }
}
{% endhighlight %}
While mistakes like that are easy to spot, subtle variations could be even more dangerous:
{% highlight swift %}
import Foundation
import XCPlayground

XCPlaygroundPage.currentPage.needsIndefiniteExecution = true
let custom_queue = dispatch_queue_create("com.akpw.bckg.worker", DISPATCH_QUEUE_SERIAL)

dispatch_async(custom_queue) {
    dispatch_sync(dispatch_get_main_queue()) {
        print("deadlocked!!! ðŸ‘»")
    }
}

// continue doing something
// ...

dispatch_sync(custom_queue) {
    if let queueLabel = currentQueueLabel(){
        print(String(format:
            "supposly running sync on the \(queueLabel)",
            "...or perhaps not???"))
    }
}
{% endhighlight %}

A rule of thumb is to avoid using _dispatch_sync_ with serial queues unless absolutely needed, and always prefer _dispatch_async_ instead.


***Global queues***

The four global concurrent queues are readily available for various concurrent tasks and typically used quite frequently in many different applications.

One thing to remember though is that these global queues are also used by the system and therefore might not be always suitable for dedicated kind of work.

A good illustration of that would be an attempt to use barrier functions there, which would simply be run as non-barrier _dispatch_async_ or dispatch_sync. This is because the global queues are shared concurrent resources, and therefore it does not make sense to serialize / block them for a single caller.


***Custom Serial Queues***

 Most common usage of custom serial queues are serializing concurrent tasks and protecting critical sections from race conditions. As mentioned above, these are rarely used along with _dispatch_sync_ and it's also not as practical to use them with  _dispatch_after.

The barrier functions would be meaningful there, as serial queues already execute their tasks one at a time.


 ***Custom Concurrent Queues***

 Concurrent custom queues is a preferred choice for running dedicated concurrent tasks in the background.

 As shown in our shape-shifting example, in combination with barrier functions they are also quite handy for resolving the readers / writers problems where a custom concurrent queue can serialize write requests while still allowing multiple read operations simultaneously.


***Conclusion***

This introductory part of the series covered Grand Central Dispatch queues and base tasks dispatching, along with common practices for selecting appropriate queue types.

All code examples are available for download readily packed in [this playground]({% if site.baseurl %}{{ site.baseurl }}{% endif %}/images/GCD_Part_I.playground.zip)

The next part will go deeper into QOS features as well as diving into more advanced GCD usage patterns.


* * *

[^1]: _QOS_CLASS_DEFAULT_ is simply a value used when no specific QOS info was provided, and is the default value for both queues and threads. Priority-wise, it sits between _User Interactive_ and _User Initiated_.

[^2]:_QOS_CLASS_UNSPECIFIED_ is tied to the concept of QOS propagation, where QoS is inferred  from the caller's QOS level. Such propagation simply transfers the QOS level, except for _User Interactive_ that is automatically translated to _User Initiated_.

[^3]:_QOS_MIN_RELATIVE_PRIORITY_ supports relative position within a QoS Class band. It is only within a given QOS class and intended for unusual situations such as e.g. interdependent work within same QOS class.
